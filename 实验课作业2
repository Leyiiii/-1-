#问题1
#3-1
a<-1
class(a)#数值型
b<-1+1i
class(b)#复数类型
c<-1L
class(c)#整型
#3-2
a<-factor(c("a","b","a"))
levels(a)#用levels函数查找因子水平值
#3-3
as.numeric("6.283185")#把字符串转换为数字
#3-4
y<-(1:3)
is.numeric(y)#y是否为数值型
is.integer(y)#是否为整型
is.array(y)#是否为数组
#3-5
rm(list=ls())#清除所有变量
#问题2
#3-1
class(Inf)#类
class(NA)
class(NaN)
class("")
typeof(Inf)#类型模式
typeof(NA)
typeof(NaN)
typeof("")
mode(Inf)#存储类型
mode(NA)
mode(NaN)
mode("")
#3-2
a<-c("dog","cat","dolphin","hamster","goldfish")
x3_2<-sample(a,100,replace = T)
print(a[1:5])
table(x3_2)
#3-3
z<-c(apple<-1,banana<-2,pear<-3,peach<-4)
ls(pattern = "a")
#问题3
#4-1
x<-c(0,0.25,0.5,0.75,1,1.25)
#4-2
x<-c(x=1,y=2,z=3)#赋值时直接命名
names(x)
names(x)<-"1"#yong names()函数改名
#4-3
x<-c(1,3,NA,6)
y<-x[!is.na(x)]#逻辑向量
x<-c(1,2,3,4,5,6,7,8)
x[5]
x[1:5]#正整数向量
x<-c(1,2,3,4,5,6,7,8)
x[-(1:5)]#负整数向量，索引向量指定被排除
books<-c(5,8,9,1)
names(books)<-c("c","r","P","j")
list<-books[c("c","P")]
print(list)#字符串向量
#4-4
d1<-c("a1","a2","a3")
d2<-c("b1","b2","b3","b4")
d3<-c("c1","c2","c3","c4","c5","c6")
z<-array(1:72,c(3,4,6),list(d1,d2,d3))
z
length(z)#3*4*6的数组的长度是72
#4-5
#%*%来执行两个矩阵的内积
#问题4
#1
a<-seq(11,50,3)
a-c(2,3)
#2
a<-seq(1.1,4,20)
a%*%c(4,5,8,9)
#3
c(1,2,4,6)+c(8,0,-1,-4)
c(1,2,4,6)-c(8,0,-1,-4)
c(1,2,4,6)%*%c(8,0,-1,-4)
c(1,2,4,6)%/%c(8,0,-1,-4)
#问题5
#练习4-1
n<-c(1:50)
tri<-c(n*(n+1)/2)
names(tri)<-letters[1:15]
tri
tri[a]
tri[5]
tri[9]
#2
d1<-c(10:0,1:11)
diag(d1)
#问题六
#5-1
l1<-list(alpha=1)
l2<- ( list(beta = 2, gamma = 3, delta = 4))
l3<-( eta = NULL)
length(l1)
length(l2)
length(l3)
#5-2
#成对列表在使用formals时
#5-3
#用date.frame创建数据框a_data_frame[2:3,-3]选择数据框中前两列的第二个和第三个元素
#5-4
#列名必须是唯一且有效的变量名称。此功能可通过给 data.frame传入check.names = FALSE关闭
#5-5
#当两个数据框有相同的列时，可使用merge函数合并，merge函数会使用两个数据框中所有共同的列但通常你会想
#用一个共享ID列
#问题7
#5-1
m1<-matrix(0:99,nrow = 10,byrow = T)
m1
list=apply(
  m1,MARGIN = 1,
  fuction(m1)
  {
    m1[round(sqrt(m1))^2==m1]
  }
)
list
#5-2
a_data_frame<-data.frame(iris)
colMeans(a_data_frame[,1:4])
#5-3
b1_data_frame<-beaver1
b2_data_frame<-beaver2
new_beaver1=data.frame(id=rep(1,114),beaver1)
new_beaver2=data.frame(id=rep(2,100),beaver2)
new_beaver=rbind(new_beaver1,new_beaver2)
new_beaver[new_beaver$activ==1,]

